#+TITLE: 项目名：LisHa
#+LANGUAGE: zh-CN
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css" />
#+OPTIONS: html-preamble:"Haskell漫谈集"
#+STARTUP: content
* 引子
  2013年9月10日，这一天是教师节，但对于一个程序员来说却没有什么特别。我坐在工位上一边翻看着软件的运行日志，一边构思着如何用Haskell实现对日志信息的自动解析，一边刷着微博。突然一条微博推荐的文章引起了我的兴趣。这篇文章(在[[http://norvig.com/lispy.html][这里]]）讲解如何利用Python实现一个简单Lisp语言解释器。印象中已经不止一次看到用某某语言实现Lisp/Scheme解释器的文章。大概因为Lisp语法简洁，又具备程序语言的基本要素，所以才被众多程序员拿来练手。

因为这篇文章的启发，正在学习Haskell的我，也有了利用Haskell实现Lisp解释器的想法。虽然Haskell版的Lisp解释器早已有之（比如[[http://www.defmacro.org/ramblings/lisp-in-haskell.html][这里]]），但我也不妨“重走一遍长征路”，以借机将已学的Haskell技术再回味琢磨一番，并在开发过程中发现问题，继续探索未知的领域。毕竟，学习一门语言，无论是自然语言还是计算机语言，最重要的都是实践。实践出真知。所以，就这么决定了，我来实现一个Haskell版的Lisp解释器。

Lisp是一门古老的语言，诞生于1958年，是现今还在广泛使用的高级语言之中的第二高龄[fn:wiki_lisp]。Lisp同时也是一个语言大家庭，在其一个甲子有余的演化过程中，衍生出众多方言，例如现在正在默默支持我写作的Emacs Lisp，以及作为通用语言而更为广泛使用的Common Lispt和Scheme。三者中，Scheme语法最为简练，也是众多Lsip解释器的首选。我们的Lisp解释器也不例外，就以Scheme为目标语言。

现在是时候给项目起个名字了。既然是以Haskell实现Lisp解释器，就将Lisp与Haskell两个词合并，项目名就叫LisHa。

[fn:wiki_lisp] 据维基百科[[http://en.wikipedia.org/wiki/Lisp_(programming_language)][Lisp词条]]，另第一高龄是Fortran。

* 为什么选择Haskell
在浸淫于C++编程工作许多年之后，我对这门语言已经有些审美疲劳。正如Stroustrup教授在2013年度Going Native大会上所说，C++是”一门轻量级抽象的编程语言“[fn:cpp]。所以，编写C++程序时总是要考虑语句是如何反映到硬件操作尤其是对内存的操作上的。这固然使得C++编译出的程序的运行效率可以和C媲美，但另一方面，也使得程序员须花大量精力考虑算法在硬件平台上的具体实现，而不能专注于算法本身，同时，也使得C++程序易于出错，难于调试。我希望能找到一门更抽象更精练的语言来换换口味。

除了C++，Python和Tcl也是我的常用编程语言。刚开始学习Python时，其清爽的语法和特色鲜明的缩进式排版都曾使我眼前一亮。但是，也许是我学艺不精，没有领会Python的精髓，在使用Python编程一段时间以后，我感觉虽然其语法非常简练，却仍然需要在设计算法时关心数据在内存中的存取。除了一些语法糖之外，本质上和C++没什么差别。至于Tcl，我无话可说。

有没有比C++和Python更加抽象的语言呢？带着这个问题，我把目光投向了一个陌生的领域——函数式编程，开始学习Haskell。函数式编程语言众多，而我之选择Haskell，纯粹是因为其据称是最具发展潜力的函数式编程语言。不管怎样，在学习了一段时间之后，我感觉Haskell正是我所寻找的那个语言。与C++及Python相比，Haskell代码更精练，用其编程时的思维方式更加抽象，同时程序更易维护。并且，Haskell于我还有一个独特的魅力，在于其更有潜力成为一种软硬兼顾的语言。有关Haskell的这些特点，且让我慢慢道来。

[fn:cpp] 英文原文“a light-weight abstraction programming language”。

** Haskell更抽象

说Haskell更抽象，其原因一言以蔽之，Haskell没有变量。

虽然在Haskell中也存在着一些类似于变量操作的语句，例如[[src:not_variable]]中的 ~let~ 语句。
#+CAPTION: Haskell中的let不是赋值
#+NAME: src:not_variable
#+INCLUDE: "../src/examples/not_variable.hs" src haskell
但这里的 ~let~ 语句并不是为变量赋值，而是定义一种关联关系，将等号右边的内容与左边的标识符相关联，使得编译器在随后的代码中一旦遇到左边的标识符，便可知其所代表的内容并进行相应的优化与编译。所以，标识符 ~a~, ~b~ 并不指代存储器中的某块空间，也就不能称为变量。在以后的讨论中我们还会看到，等号左边的形式不仅限于一个标识符，还可以是函数定义，以及多种复杂的匹配模式，这也远不是赋值语句所能解释的。

对于象我一样，从VB/Pascal/C/C++等等的语言开始编程之路的程序员来说，变量仿佛是程序语言中天然存在一样。我们利用变量保存数据、传递函数参数、控制循环等等，可以说变量是编程解题的重要工具，不可或缺。但是，居然有一种程序语言没有变量，听起来有些不可思议。更不用说，当我发现，因为没有办法声明循环变量，所以Haskell连循环也不支持时的惊讶感觉。显然，C++编程中的那些惯用的解题思路在Haskell中不并适用。

为什么Haskell没变量，在回答这个问题之前，我们需要先讨论清楚变量是什么。

*** 变量的本质

首先，变量是数据的容器。我们可以从变量中读出数据，也可以向其写入数据。但在同一时刻，我们只可能或者从其读出或者向其写入数据，且新写入的数据将覆盖原有数据。无论是C++，Python，Java，Delphi还是什么其它语言（当然，不包括Haskell），其变量都满足以上描述。数据结构或者算法的书籍在介绍变量这个概念时通常都会用交换两变量内的数据为例来演示变量作为数据的功能。对于一般数据类型，要交换两变量中的数据，总是要引入第三个变量来保存中间数据。例如，在C++中交换两变量数据的函数模板如[[src:cpp_swap]]所示。
#+CAPTION: C++，交换两变量值的函数模板
#+NAME: src:cpp_swap
#+BEGIN_SRC c++
template<typename T>
void swap(T &a, T &b) {T c = a; a = b; b = c;}
#+END_SRC
至于其它语言，虽然实现方式千差万别，但都或显式或隐式地引入第三个变量以保存中间数据。例如在Python中，通常用以下语句交换两个变量中的数据：
#+BEGIN_SRC python
a, b = b, a # 隐含构造一个元组
#+END_SRC
等号右边的 ~b, a~ 实际上隐含构造了一个二元组，其中保存了对变量b和a所引用的数据的引用。

可见，即使像“交换两变量值”这样简单的算法，也会因为变量的约束而变得略微繁琐。更不用对于说排序、查找等等复杂的算法，程序员除了要考虑数据之间的计算关系之外，还要考虑另一个非常重要的问题，即数据在变量中的存取时机。只有在正确的时机从变量中读出数据，做出正确的运算得到新数据，并在正确的时机写入正确的变量，才能使得程序得到正确的结果。

其次，无论其类型如何，程序语言中的变量最终都将指代存储器（CPU寄存器，内存，或者外设中的存储器）中的某块存储空间。所以可以说，变量是程序语言对存储空间的抽象，也是程序员用以控制存储空间的媒介。变量的存在，反过来说明该程序语言还无法根据算法描述自动规划数据在存储器间的存取时机，而有赖于程序员通过对变量的操作给定。

**** 禁用变量的好处与不足

Haskell不提供变量，也就阻断了程序员直接操作存储器的通路。所以用Haskell实现某个算法时，必须将原本对存储器的直接操作需求，提炼成更为抽象的数据间的映射关系，再写成代码。Haskell编译器将根据代码自动规划变量的声明，回收及对其的读写，以正确实现算法的功能。

这样做的一个明显的好处，就是Haskell程序员不必花费大量精力去规划变量的存取时机，可以专注于算法本身的数据映射的正确性上。程序设计中，有很大一部分错误是由于不当的变量存取时机引起的。由Haskell编译器自动规划的变量存取，总可以保证其正确反映代码的意图。所以，只要代码所设计的算法间的数据映射关系正确，则编译出的目标代码就可以得到正确的结果。这大大降低了程序出错的概率，使得代码更加可读也更易维护。《Real World Haskell》的作者曾在该书前言中说到：
#+BEGIN_QUOTE
Even with years of experience, we remain astonished and pleased by how often our Haskell programs simply work on the first try, once we fix those compilation errors.

我们经常发现，在修复所有的编译错误后Haskell程序第一次运行便可正确工作。对此，即使有多年经验的我们仍然会感到惊讶与欣喜。
#+END_QUOTE
对此，仅有一点Haskell编程经历的我深表赞同。

当然，禁用变量也有代价。编译器自动规划的变量存取肯定不如有经验的程序员所作的规划那样高效，所以Haskell的程序运行时间无法与C/C++程序相比。另外，虽然变量规划由编译器包办，但其具体实现还是依赖于代码的说明。同一个算法，可以有多种Haskell代码实现，也就有可能导致不同的变量规划，从而导致程序运行效率之不同。要提高Haskell程序的运行效率，还是需要对Haskell中的变量规划，内存管理有一定了解。所以，Haskell提高了一定高度的抽象，但还不能完全摆脱对存储器结构的依赖。

*** 函数式编程

由于没有变量，也没有循环，所以通常的编程思路组织方式如流程图、伪码等对Haskell并不适用。那么，Haskell的编程思路应该如何组织呢？答案是函数式编程。让我们通过一个实际的算法例子来体会什么是函数式编程。

**** 冒泡函数

回到“交换两个变量中的数据”的问题。由于Haskell中没有变量，所以也无需去交换两个变量的数据。那么，在其它语言中需要交换两个变量的算法，在Haskell中应该如何实现呢？比如，冒泡排序就是一个典型的需要交换两变量数据的算法。为了简化讨论，我们在这里只考虑冒泡排序中的冒泡问题，即给定一个序列，如何将该序列的最大元素移动到序列首。并且，由于Haskell中最方便的数据结构是单向链表，在此，我们约定序列是保存在单向链表中。

在有变量的程序语言中，冒泡问题可以通过一个循环解决。通过循环，从链表首节点遍历到链表的尾节点之前的节点，当当前节点的数据大于下一个节点的数据时，交换这两个节点的数据[fn:exchange_node]。这样，遍历结束后，最大数据将保存在链表尾节点中。最后，再交换链表首尾节点的数据即可。该算法的一个最简单的C++实现如[[src:cpp_bubble]]所示。
#+CAPTION: C++的冒泡算法实现
#+NAME: src:cpp_bubble
#+INCLUDE: "../src/examples/bubble.cpp" src c++ :lines "6-23"

但是，要使用Haskell解决冒泡问题，我们必须忘记变量、忘记循环，从程序语言诞生之前的人类智慧——数学中寻找思路。

具体来说，我们需要构造出一个函数，函数的输入是某种形式的序列，输出也是同种形式的序列，并且满足输出序列是输出序列的重排列且输出序列的首元素是序列中的最大元素。由于问题中并没有约束序列的长度（即列表的元素数），所以构造出的函数（或者函数集）必须能处理任意长度为 $n$ 的序列。

对于这种针对任意整数 $n$ 的函数构造或证明，数学上有一个强有力的工具，即数学归纳法。假设针对长度为 $n-1$ 的序列，我们已经构造出满足条件的函数 $Bub^{n-1}$ ，那么，如果可以利用 $Bub^{n-1}$ 构造出针对长度为 $n$ 的序列的函数 $Bub^n$ ，并且针对元素为1的序列找到一个种子函数 $Bub^1$ ，则根据数学归纳法，我们便可以为任意长度的序列构造冒泡函数，从而解决冒泡问题。

种子函数 $Bub^1$ 很容易找到。对于长度为1的序列，其本身已经满足首元素最大，所以函数无需对序列做任何操作，只需要返回该序列即可，既 $Bub^1(L)=L$ 。

问题的关键在于找到从 $Bub^{n-1}$ 构造 $Bub^n$ 的方法。这也不是什么难事。当 $n>0$ 时，长度为 $n$ 的序列 $L$ 总可以分解成首元素 $e$ 和将 $e$ 从 $L$ 中移除后的剩余序列 $L_r$ 。 $L_r$ 长度为 $n-1$ ，所以可以通过 $Bub^{n-1}$ 得到冒泡后的序列 $L'=Bub^{n-1}(L_r)$ 。同样， $L'$ 也可以分解成其首元素 $e'$ 和剩余序列 $L'_r$ 。此时， $L$ 已经经过两重分解，得到两个元素 $e$ 、 $e'$ 和一个剩余序列 $L'_r$ ，并且对于 $L'_r$ 中的任意元素 $e_r$ ，都满足 $e'>e_r$ 。那么，当 $e'>e$ 时， $e'$ 就是序列 $L$ 中最大的元素，否则 $e$ 就是最大元素，只需选择其中较大者做为函数返回序列的首元素，再与较小者和剩余序列 $L'_r$ 组成完整序列即可。

将以上讨论中所用到的几种对序列的操作，以函数的形式标记如下：
  * $Head(L)$ 返回序列的首元素。
  * $Tail(L)$ 返回序列将首元素移除后的剩余序列。
  * $Cons(e, L)$ 构造一个新序列 $L'$ ， $L'$ 满足 $Head(L')=e$ 及 $Tail(L')=L$ 。
对于单向链表，以上几种函数的操作都很容易实现。

那么，冒泡函数 $Bub^n$ 可以写成如下形式。
\begin{equation}
\begin{array}{rcl}
Bub^1(L) & = & L \\
Bub^n(L) & = &
\left\{ 
\begin{array}{ll}
Cons(e, Cons(e', L_r')) & \textrm{if $e>e'$} \\
Cons(e', Cons(e, L_r')) & \textrm{otherwise}
\end{array}
\right. \\
& \textrm{Where} & 
\begin{array}{rcl}
e & = & Head(L) \\
L_r & = & Tail(L) \\
L' & = & Bub^{n-1}(L_r) \\
e' & = & Head(L') \\
L_r' & = & Tail(L')
\end{array}
\end{array}
\end{equation}

Haskell的一大魅力在于，很多时候，我们可以轻易地将解题公式翻译成Haskell代码。例如上面的公式，可以照翻成如[[src:haskell_bubble]]所示的Haskell冒泡函数 ~bub~ 的代码。
#+CAPTION: Haskell的冒泡函数
#+NAME: src:haskell_bubble
#+INCLUDE: "../src/examples/bubble.hs" src haskell :lines "0-9"
在此我们不讨论代码细节及其可改进之处。只需大概看一下代码的排版，即使是不了解Haskell的人也能发现代码与上述公式的相似之处，如果再将关键字 ~otherwise~ 与公式中的文字对比一下，也许还能猜出 ~|~ 在这段Haskell中的含义。

通过这个实例，我们可以体会出Haskell编程思路的特点。由于没有变量，编程只需专注于设计数据之间的映射关系。在数学上，表示两个数据之间映射关系的实体就是函数。所以，Haskell的编程思路，首先是如何将问题用函数的形式描述，其次是如何构造解决问题所需的函数，最后，以此为参考写出Haskell代码。

乍看之下，Haskell的这种思路有违于编程常识。但仔细想想，在计算机出现之前，函数才是解决数学计算问题的不二法门。只是在图灵机、冯·诺依曼机等等针对硬件可实现的自动计算原型出现之后，编程思路才囿于变量、循环之中不自知，反而疏远了问题的数学本质。Haskell摒弃变量，将程序的计算模型封装起来，也迫使程序员的思路更接近问题的数学本质。所以说，Haskell更抽象。

试想，将以上冒泡算法的C++代码和Haskell代码向一位19世纪的学者解释时，哪个他更容易理解呢。我想应该是Haskell吧。

[fn:exchange_node] 当数据尺寸较大，使得交换两数据的运行开销较大时，更经济的方法是交换两节点在链表中的位置。在此，为使讨论简单，只考虑交换两数据的情况。
** Haskell代码更易复用
可复用的代码对于一个软件项目的开发总是会起到事半功倍的效果。一方面，作者可以用更精炼的代码解决问题；更为重要的另一方面是，复用代码对于维护者更加容易理解。在软件开发中，代码作者与维护者不同是常有的事情。维护者花费一段时间和精力理解了某个函数，然后发现这个函数在多处复用，从而自己也可以“复用”对该函数的理解而更快理解其它代码，这是多么令人身心愉悦的事情。与之相反，在看到有如散文一样信马由缰，以复制粘贴为复用基本方法的代码时，维护者在心里定会咒骂这个作者。

要写出结构精巧，高度复用的代码，作者对问题的提炼与抽象固然必不可少，编程语言能为代码复用提供多少技术支持也很重要。如果是用汇编语言编程，则再多的分解与抽象也将无用武之地。不同的语言之间，复用的实现方式也不尽相同，要为众多语言定一个令人信服的复用性的绝对排名显然是不可能的，也超出我的能力。基于两个原因，在此仅就Haskell与C++两种语言基于我的理解做一个定性的比较。首先，C++是我最熟悉的语言，没有之一。另外，C++与Haskell一样，都是强类型语言，C++的变量与Haskell中的符号都有类型，不同类型之间不能赋值或关联。这使得二者的代码复用机制有一定相似之处，便于比较。

*** 语言的复用性
语言的复用性这个概念过于笼统。我们需要先对其进一步细分，才好对Haskell和C++两种语言做逐项比较。

首先，数据结构和算法是高级编程语言的两大基本要素。据此，我们可以将代码复用分成三种：数据结构复用数据结构、算法复用数据结构以及算法复用算法。这里所说的甲方复用乙方，是指在甲方的代码中用到乙方代码的定义。以下讨论中，我们用甲方乙方分别指代复用方代码与被复用方代码。另外，此处的数据结构是纯粹的数据的结构化描述，不包含如面向对象设计中的成员函数那样与数据结构相关的算法，所以，不存在数据结构复用算法的情况。

即使是同一种复用，也可以继续细分为特定与非特定的两种复用机制，两者的区别在于乙方代码的定义是否在甲方代码范围内已知，如是则为特定复用，否则为非特定复用。

特定复用是编程语言的非常基本的功能。例如在定义某个复杂结构体时用到另一个结构体的定义，可归为数据结构间的特定复用；在函数中调用另一个函数则为算法间的特定复用；而在函数中利用某个复杂结构体保存数据或函数参数，则为算法特定复用数据结构。C++和Haskell都具备以上这些基本功能，二者在特定复用上不分高下，在此不做过多讨论。

特定复用是甲方与有限的若干乙方代码之间的复用关系，而非特定复用由于乙方代码不确定，是甲方与（理论上）无限的乙方代码之间的复用关系。任何特定复用都可以通过将乙方代码抽象而提升为非特定复用，所以，非特定复性所代表的复用性更高。要比较语言的复用性，需要对其非特定复用功能着重讨论。

*** 泛型编程
我们首先讨论数据结构对数据结构以及算法对数据结构的非特定复用。这两种复用统称为对数据结构的非特定复用。由于所复用的是不特定的数据结构定义，在强类型语言中，这属于泛型编程（Generic Programming）的范畴。

C++的泛型编程是通过以类型为参数的类模板和函数模板实现的。乙方的数据结构被抽象成模板的类型参数，从而任何满足模板的隐含要求的类型都可以应用于甲方的模板代码而生成对应的模板实例。如[[src:cpp_template]]所示的代码中，类模板 =pair= 可以生成针对任意类型的数据对类型，函数模板 =sqsum= 返回任意类型的两个数的平方和。 =sqsum= 模板可用于计算整数、浮点数、复数或者有理数的平方和。
#+CAPTION: C++的类模板与函数模板
#+NAME: src:cpp_template
#+INCLUDE: "../src/examples/cpp_template.cpp" src c++ :lines "2-13"

Haskell拥有一种与C++模板类似的机制——多态（Polymorphism）。如果一个类型定义中带有参数，则该类型是一个多态类型，参数指代另一种类型。如果一个函数的类型定义（函数的类型由其输入参数类型及返回值类型决定）中包含参数，则函数是一个多态函数。[[src:hs_polymorphism]]的代码演示了在Haskell中如何利用多态定义与[[src:cpp_template]]类似的泛型数据结构与算法。
#+CAPTION: Haskell的多态类型与函数
#+NAME: src:hs_polymorphism
#+INCLUDE: "../src/examples/polymorphism.hs" src haskell :lines "0-11"

这样看来，似乎Haskell与C++在泛型编程上不相上下。但依愚见，Haskell要略胜一筹。

C++的模板机制有一个很恼人的缺陷，就是缺乏模板对类型参数要求的成文描述。在[[src:cpp_template]]中的平方和函数 =sqsum= 中要对两个函数参数做乘法和加法，这实际上要求函数参数的类型，即模板的类型参数，必须支持乘法和加法运算，否则将会编译出错。但是，由于模板的参数都只是用关键字 =typename= 标识，根本无法反映如上的函数对模板参数的隐含要求。这将导致编译器无法在早期锁定错误，也无法在编译出错时给出正确的错误原因。例如，我们将 =std::string= 值（即字符串）传给 =sqrt= 函数参数时（如[[src:cpp_wrong_concept]]所示），GCC 4.6.4将给出如下的报错信息，示意错误在函数模板中，而不在调用函数模板时。
#+CAPTION: 不满足模板隐含要求的参数类型
#+NAME: src:cpp_wrong_concept
#+BEGIN_SRC c++
  // std::string类型不能进行乘法和加法运算。
  std::cout << sqsum(std::string("abc"), std::string("def")) << std::endl;
#+END_SRC

#+CAPTION: GCC的含混报错信息
#+BEGIN_EXAMPLE
cpp_template.cpp: 在函数‘T sqsum(const T&, const T&) [with T = std::basic_string<char>]’中:
cpp_template.cpp:24:60：从此处实例化
cpp_template.cpp:11:58: 错误： ‘operator*’在‘v2 * v2’中没有匹配
cpp_template.cpp:11:58: 错误： ‘operator*’在‘v1 * v1’中没有匹配
#+END_EXAMPLE
对于像标准模板库（Standard Template Library, STL）中那些深度依赖模板的库函数，一但用错，将产生大量误导的编译报错信息。这使得模板编程虽然是C++的一大强力工具，却被大多数不熟悉模板的程序员视为畏途，敬而远之。

虽然C++界内曾经尝试为模板参数增加成文的要求，但这一提案最终被最新标准C++11排除在外，似乎也不在C++14的草案之中。那么，C++模板的这一痼疾在近期治愈无望。

Haskell对多态的处理要更为严谨。在[[src:hs_polymorphism]]中的 ~sqsum~ 函数中，为了声明这是一个多态函数，我们必须为该函数添加类型声明：
#+INCLUDE: "../src/examples/polymorphism.hs" src haskell :lines "7"
声明中的 ~a~ 是类型符号， ~a->a->a~ 声明函数类型为接受任意 ~a~ 类型的两个参数并返回一个 ~a~ 类型值（其中另有玄机，暂且不论）。这个 ~sqsum~ 函数中同样需要对 ~a~ 类型的参数 ~x~ 和 ~y~ 作乘法和加法运算。为了体现函数对类型的要求，我们必须在类型声明之前添加 ~Num a =>~ ，这个声明约束类型 ~a~ 必须是类型族（type class） ~Num~ 的一员。 ~Num~ 是Haskell中预定义的类型族，族中都是可以进行加、减、乘、求负数、求符号运算的类型。满足要求的Haskell预定义类型也已经是该族成员。如果要将自定义类型加入该族，就必须为类型提供族所要求的运算函数。另外，Haskell也允许自定义类型族。

类型族从两方面防止了C++模板的痼疾在Haskell中出现。一方面，在多态函数中，如果某个符号类型由类型符号决定，则只可将约束该符号类型的类型族中定义的函数（加、减等等运算符也是函数）应用于该符号。如果某个类型符号不受任何类型族约束，则以之为类型的符号不能进行任何函数运算。如果将[[src:hs_polymorphism]]中 ~sqsum~ 的类型族约束 ~Num a~ 删除，则GHC编译该代码时将报错，指出不能将 ~x~ 和 ~y~ 应用于 ~Num~ 类型族的运算 ~+~ 。这一提示非常明确，足够程序员精准定位错误所在并改正。

另一方面，在将多态函数应用于某个类型的值时，编译器也会检查该类型是否是对应类型族的成员。例如将 ~sqsum~ 应用于两个字符串时：
#+BEGIN_SRC haskell
sqsum "abc" "def"
#+END_SRC
由于 ~"abc"~ 和 ~"def"~ 的类型 ~String~ (即字符串类型)不是 ~Num~ 类型族的成员，编译器将直接报错，指出该错误，而不用像C++的编译器那样直到编译乘法和加法表达式时才发现有错，而给出误导的报错信息。

可见，由于类型族的存在，Haskell的泛型编程机制要比C++更为完善。从代码复用的角度审视，在对数据类型的非特定复用上，Haskell要略胜于C++。但这只是二者在代码复用差距中的一小部分。更为显著的差距，出现在我们尚未讨论过的算法对算法的非特定复用上。

*** 函数指针与闭包
算法间的两种复用可以说是处在代码复用发展道路的两极上。早在汇编语言时代，算法间的特定复用，即已知函数之间的相互调用，就已经是寻常功能了。非特定复用，即在函数中调用不特定的其他函数，则一直作为一种较为高级的语言特性，不在众多现代编程语言的“常所用挌虎大戟”之列。
[[file:images/halberd.jpg]]

在对数据结构的非特定复用中，无论是C++和Haskell都必须提供某种形式的参数以指代所复用的数据结构。C++中是类型模板参数，Haskell中是类型符号。同样，在对算法的非特定复用中，也需要某种参数以指代所复用的算法。

C++是以函数指针来指代所复用的算法，即某个函数。C++声明函数指针类型的语法颇为怪异，例如以下的代码将声明一个函数指针类型 ~func_ptr_type~ 。
#+BEGIN_SRC c++
  typedef int (*func_ptr_type)(char, double);
  // 声明func_ptr_type是一个函数指针类型，只能指向接受两个char和double类
  // 型参数且返回int值的函数。
#+END_SRC
从代码中可以看出，函数指针类型中已经包含了对函数参数个数、类型以及返回值类型的约束信息。所以，某种类型的函数指针只能指向特定参数类型和数目以及返回值类型的函数。将函数指针与模板的类型参数相结合，在C++中可以写出针对不同参数类型的函数的复用代码，但仍然要求函数参数数目固定。例如[[src:cpp_func_ptr]]中所示的函数模板 ~chain~ ，对于任意两个单参数函数 ~func0~ 和 ~func1~ ，只要满足 ~func1~ 的返回值与 ~func0~ 的参数值类型相同，就对某个 ~func1~ 的参数类型的值，返回连锁调用 ~func1~ 及 ~func0~ 所得到的值。
#+CAPTION: C++函数指针
#+NAME: src:cpp_func_ptr
#+INCLUDE: "../src/examples/function_pointer.cpp" src c++ :lines "6-19"

假如我们有函数 ~root3~ 和 ~root4~ 分别计算整数的三次方根和四次方根的浮点值，又有函数 ~double_to_string~ 返回浮点值对应的字符串表示，那么借助 ~chain~ 函数模板，我们可以复用以上三个函数而分别实现计算并返回某个整数值的三次方根及四次方根的字符串表示的功能，如[[src:cpp_func_reuse]]所示。
#+CAPTION: 复用函数以实现新功能
#+NAME: src:cpp_func_reuse
#+INCLUDE: "../src/examples/function_pointer.cpp" src c++ :lines "20-35"

但这种直接调用函数指针的方式对代码复用的贡献非常有限。如果要实现三个函数之间的连锁调用，则我们需要另外再写一个 ~chain3~ 函数模板，而不能复用已有的 ~chain~ 。要实现最大限度的算法复用，我们需要有一种“闭合”的函数复用机制，即根据已有的函数生成新的函数。这样，新生成的函数才有可能再利用现有的函数复用机制再生成新函数，从而提高代码的复用性。但是，要实现

，对算法的非特定复用是通过函数指针结合模板来实现的，但声明函数指针类型的语法之怪异足以对C++的函数复用产生负面影响。比如以下代码，其实是声明了一个函数 =apply_on_pair= ，其第一个参数 =func= 是一个接受两个字符串的值并返回另一字符串值的函数。
#+BEGIN_SRC c++
using namespace std;
string apply_on_pair(string (*func)(string const &, string const &),
                     string const &a, string const &b)
{
  return func(a, b);
}
#+END_SRC
这种将变量名（ =func= ）隐藏于其类型声明之中的语法实在有违为常人的思维习惯。为使代码易于理解，C++的程序员通常用 =typedef= 为函数类型赋名。于是，以上代码可以改写成：
#+INCLUDE: "../src/examples/function_pointer.cpp" src c++ :lines "4-11"
这样一来，函数定义是好理解了。不过，类型定义呢？更何况，当指针类型与模板参数相结合时，情况变得更糟。如果要声明一个接受任意类型两个值并返回同类型值的函数为参数的函数模板时，由于函数类型依赖于模板参数，我们无法直接用 =typedef= 为其预先赋名，只能先预定义一个求出类型的元函数（一种完全用于类型推导的类模板），再利用该元函数“求得”函数指针类型，如[[src:function_pointer]]所示：
#+CAPTION: 用元函数推导函数指针类型
#+Name: src:function_pointer
#+INCLUDE: "../src/examples/function_pointer.cpp" src c++ :lines "12-27"

C++还有诸如函数指针类型的模板参数等机制以支持算法的非特定复用，在此不再深入。仅以上示例就已经可以说明，在C++中实现算法间的复用需要对模板技巧有所了解，其代码也显得较繁琐。这无形中提高了算法复用的门槛，将众多并不完全了解C++的程序员挡在门外。

Haskell作为一门函数式编程语言，对函数间复用的支持要比C++简便得多，也丰富得多。在Haskell中，函数是“一等公民”，可以直接作为与符号或者函数参数绑定。函数类型的声明也比C++更为直观。在Haskell中实现多态的 =apply_on_pair= 函数的代码如[[src:hs_func_param]]所示。
#+CAPTION: Haskell的函数参数类型声明
#+NAME: src:hs_func_param
#+INCLUDE: "../src/examples/functional.hs" src haskell :lines "1-3"
之前已经提过，Haskell中函数的类型声明的形式为： ~参数类型1->参数类型2->...->返回类型~ 。如果某个参数本身是函数，那么需要用括号将该参数的类型嵌入到函数类型声明中。
