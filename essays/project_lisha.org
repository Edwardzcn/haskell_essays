#+TITLE: 项目名：LisHa
#+LANGUAGE: zh

* 引子
  2013年9月10日，这一天是教师节，但对于一个程序员来说却没有什么特别。我坐在工位上一边翻看着软件的运行日志，一边构思着如何用Haskell实现对日志信息的自动解析，一边刷着微博。突然一条微博推荐的文章引起了我的兴趣。这篇文章(在[[http://norvig.com/lispy.html][这里]]）讲解如何利用Python实现一个简单Lisp语言解释器。印象中已经不止一次看到用某某语言实现Lisp/Scheme解释器的文章。大概因为Lisp语法简洁，又具备程序语言的基本要素，所以才被众多程序员拿来练手。

因为这篇文章的启发，正在学习Haskell的我，也有了利用Haskell实现Lisp解释器的想法。虽然Haskell版的Lisp解释器早已有之（比如[[http://www.defmacro.org/ramblings/lisp-in-haskell.html][这里]]），但我也不妨“重走一遍长征路”，以借机将已学的Haskell技术再回味琢磨一番，并在开发过程中发现问题，继续探索未知的领域。毕竟，学习一门语言，无论是自然语言还是计算机语言，最重要的都是实践。实践出真知。所以，就这么决定了，我来实现一个Haskell版的Lisp解释器。

Lisp是一门古老的语言，诞生于1958年，是现今还在广泛使用的高级语言之中的第二高龄[fn:wiki_lisp]。Lisp同时也是一个语言大家庭，在其一个甲子有余的演化过程中，衍生出众多方言，例如现在正在默默支持我写作的Emacs Lisp，以及作为通用语言而更为广泛使用的Common Lispt和Scheme。三者中，Scheme语法最为简练，也是众多Lsip解释器的首选。我们的Lisp解释器不例，就以Scheme为目标语言。

现在是时候给项目起个名字了。既然是以Haskell实现Lisp解释器，就将Lisp与Haskell两个词合并，项目名就叫LisHa。

[fn:wiki_lisp] 据维基百科[[http://en.wikipedia.org/wiki/Lisp_(programming_language)][Lisp词条]]，另第一高龄是Fortran。

* 为什么选择Haskell
在浸淫于C++编程工作许多年之后，我对这门语言已经有些审美疲劳。正如Stroustrup教授在2013年度Going Native大会上所说，C++是”一门轻量级抽象的编程语言“[fn:cpp]。所以，编写C++程序时总是要考虑语句是如何反映到硬件操作尤其是对内存的操作上的。这固然使得C++编译出的程序的运行效率可以和C媲美，但另一方面，也使得程序员须花大量精力考虑算法在硬件操作上的具体实现，而不能专注于算法本身，同时，也使得C++程序易于出错，难于调试。我希望能找到一门更抽象更精练的语言来换换口味。

除了C++，Python和Tcl也是我的常用编程语言。刚开始学习Python时，其清爽的语法和特色鲜明的缩进式排版都曾使我眼前一亮。但是，也许是我学艺不精，没有领会Python的精髓，在使用Python编程一段时间以后，我感觉虽然其语法非常简练，却仍然需要在设计算法时关心数据在内存中的存取。除了一些语法糖之外，本质上和C++没什么差别。至于Tcl，我无话可说。

有没有比C++和Python更加抽象的语言呢？带着这个问题，我把目光投向了一个陌生的领域——函数式编程，开始学习Haskell。函数式编程语言众多，而我之选择Haskell，纯粹是因为其据称是最具发展潜力的函数式编程语言。不管怎样，在学习了一段时间之后，我感觉Haskell正是我所寻找的那个语言。与C++及Python相比，Haskell代码更精练，用其编程时的思维方式更加抽象，同时程序更易维护。而Haskell于我还有一个独特的魅力，在于其更有潜力成为一种软硬兼顾的语言。有关Haskell的这些特点，且让我慢慢道来。

[fn:cpp] 英文原文“a light-weight abstraction programming language”。

** TODO 什么是函数式编程
** TODO Haskell更抽象
   * [ ] 补一种编程范式。
   * [ ] 补上Python, Perl, Java以及Delphi交换变量值的例子。
无论是用C++，Python，Perl，Java还是Delphi编程时，无论是面向过程、面向对象、泛型还是面向~__~，我们在实现某个算法时除了要考虑数据之间的计算关系之外，还要考虑另一个非常重要的问题，即数据在变量中的存取时机。以一个最简单算法——交换两个变量中的数据为例。无论上述哪种语言，要实现交换两个变量中的值，都需要第三个变量，如以下所示：
#+BEGIN_SRC C++
template<typename T>
void swap(T &a, T &b) {T c = a; a = b; b = c;}
#+END_SRC

变量作为数据的容器，在程序语言中仿佛是天然存在一样。任何数据结构或者算法书籍在介绍变量这个概念时都会以上例来演示变量的特性——变量可以保存数据，且新保存的数据将覆盖原有数据，并以此作为随后所有数据结构与算法的基石。其实，无论变量类型如何，其最终将指代存储器（CPU寄存器，内存，或者外设中的存储器）中的某块存储空间。所以，变量是程序语言对存储空间的抽象，也是程序员用以控制存储空间的媒介。也正因为变量的存在，说明该程序语言无法根据算法描述自动规划数据在存储器间的存取时机，而有赖于程序员通过对变量的操作给定。在这一点上，变量之于程序语言，相当于离合器之于汽车。同样，驾驶手动档汽车的驾驶员，除了要规划路径，观察路面情况外，还要分出一部分精力注意发动机转速并及时换档。

那么，之所以说Haskell更抽象，其中一个重要原因就在于， *Haskell没有变量* 。
