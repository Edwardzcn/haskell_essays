#+TITLE: 项目名：LisHa
#+LANGUAGE: zh_CN

* 引子
  2013年9月10日，这一天是教师节，但对于一个程序员来说却没有什么特别。我坐在工位上一边翻看着软件的运行日志，一边构思着如何用Haskell实现对日志信息的自动解析，一边刷着微博。突然一条微博推荐的文章引起了我的兴趣。这篇文章(在[[http://norvig.com/lispy.html][这里]]）讲解如何利用Python实现一个简单Lisp语言解释器。印象中已经不止一次看到用某某语言实现Lisp/Scheme解释器的文章。大概因为Lisp语法简洁，又具备程序语言的基本要素，所以才被众多程序员拿来练手。

因为这篇文章的启发，正在学习Haskell的我，也有了利用Haskell实现Lisp解释器的想法。虽然Haskell版的Lisp解释器早已有之（比如[[http://www.defmacro.org/ramblings/lisp-in-haskell.html][这里]]），但我也不妨“重走一遍长征路”，以借机将已学的Haskell技术再回味琢磨一番，并在开发过程中发现问题，继续探索未知的领域。毕竟，学习一门语言，无论是自然语言还是计算机语言，最重要的都是实践。实践出真知。所以，就这么决定了，我来实现一个Haskell版的Lisp解释器。

Lisp是一门古老的语言，诞生于1958年，是现今还在广泛使用的高级语言之中的第二高龄[fn:wiki_lisp]。Lisp同时也是一个语言大家庭，在其一个甲子有余的演化过程中，衍生出众多方言，例如现在正在默默支持我写作的Emacs Lisp，以及作为通用语言而更为广泛使用的Common Lispt和Scheme。三者中，Scheme语法最为简练，也是众多Lsip解释器的首选。我们的Lisp解释器不例，就以Scheme为目标语言。

现在是时候给项目起个名字了。既然是以Haskell实现Lisp解释器，就将Lisp与Haskell两个词合并，项目名就叫LisHa。

[fn:wiki_lisp] 据维基百科[[http://en.wikipedia.org/wiki/Lisp_(programming_language)][Lisp词条]]，另第一高龄是Fortran。

* 为什么选择Haskell
在浸淫于C++编程工作许多年之后，我对这门语言已经有些审美疲劳。正如Stroustrup教授在2013年度Going Native大会上所说，C++是”一门轻量级抽象的编程语言“[fn:cpp]。所以，编写C++程序时总是要考虑语句是如何反映到硬件操作尤其是对内存的操作上的。这固然使得C++编译出的程序的运行效率可以和C媲美，但另一方面，也使得程序员须花大量精力考虑算法在硬件操作上的具体实现，而不能专注于算法本身，同时，也使得C++程序易于出错，难于调试。我希望能找到一门更抽象更精练的语言来换换口味。

除了C++，Python和Tcl也是我的常用编程语言。刚开始学习Python时，其清爽的语法和特色鲜明的缩进式排版都曾使我眼前一亮。但是，也许是我学艺不精，没有领会Python的精髓，在使用Python编程一段时间以后，我感觉虽然其语法非常简练，却仍然需要在设计算法时关心数据在内存中的存取。除了一些语法糖之外，本质上和C++没什么差别。至于Tcl，我无话可说。

有没有比C++和Python更加抽象的语言呢？带着这个问题，我把目光投向了一个陌生的领域——函数式编程，开始学习Haskell。函数式编程语言众多，而我之选择Haskell，纯粹是因为其据称是最具发展潜力的函数式编程语言。不管怎样，在学习了一段时间之后，我感觉Haskell正是我所寻找的那个语言。与C++及Python相比，Haskell代码更精练，用其编程时的思维方式更加抽象，同时程序更易维护。而Haskell于我还有一个独特的魅力，在于其更有潜力成为一种软硬兼顾的语言。有关Haskell的这些特点，且让我慢慢道来。

[fn:cpp] 英文原文“a light-weight abstraction programming language”。

** TODO Haskell更抽象

*** 变量的本质
无论是用C++，Python，Java还是Delphi编程时，无论是面向过程、面向对象、还是泛型编程，我们在实现某个算法时除了要考虑数据之间的计算关系之外，还要考虑另一个非常重要的问题，即数据在变量中的存取时机。

变量作为数据的容器，在程序语言中仿佛是天然存在一样。我们可以从变量中读出数据，也可以向其写入数据。但在同一时刻，我们只可能或者从其读出或者向其写入数据，且新写入的数据将覆盖原有数据。数据结构或者算法书籍在介绍变量这个概念时通常都会用交换两变量内的数据为例来演示变量的这一特性。对于一般数据类型，要交换两变量中的数据，总是要引入第三个变量来保存中间数据。例如，在C++中交换两变量数据的函数如以下所示。
#+BEGIN_SRC c++
template<typename T>
void swap(T &a, T &b) {T c = a; a = b; b = c;}
#+END_SRC
至于其它语言，虽然实现方式千差万别，但都或显式或隐式地引入第三个变量以保存中间数据。例如在Python中，通常用以下语句交换两个变量中的数据：
#+BEGIN_SRC python
a, b = b, a # 隐含构造一个元组
#+END_SRC
其中，等号右边的 ~b, a~ 实际上隐含构造了一个二元组，其中保存了对变量b和a所引用的数据的引用。

可见，即使像“交换两变量值”这样简单的算法，也会因为变量的约束而变得略微繁琐。更不用说排序、查找等等更加复杂的算法，更需要程序员仔细规划变量的读写时机，以求得正确的结果。

变量的本质是对存储空间的抽象。无论程序语言中的变量类型如何，其最终将指代存储器（CPU寄存器，内存，或者外设中的存储器）中的某块存储空间。所以说，变量是程序语言对存储空间的抽象，也是程序员用以控制存储空间的媒介。也正因为变量的存在，说明该程序语言无法根据算法描述自动规划数据在存储器间的存取时机，而有赖于程序员通过对变量的操作给定。

*** Haskell没有变量

说Haskell更抽象，其原因一言以蔽之，Haskell没有变量。

虽然，在Haskell中也存在着一些类似于变量操作的语句，例如下例中的 ~let~ 语句。
#+INCLUDE: "../src/examples/not_variable.hs" src haskell
但这里的 ~let~ 语句并不是为变量赋值，而是定义一种关联关系，将等号右边的内容与左边的标识符相关联，使得编译器在随后的代码中一旦遇到左边的标识符，便可知其所代表的内容并进行相应的优化与编译。所以，标识符 ~a~, ~b~ 并不指代存储器中的某块空间，也就不能称为变量。在以后的讨论中我们还会看到，等号左边的形式不仅限于一个标识符，还可以是函数定义，以及多种复杂的匹配模式，这也远不是赋值语句所能解释的。

Haskell不提供变量，也就阻断了程序员直接操作存储器的通路。所以，用Haskell实现某个算法时，必须将原本对存储器的直接操作需求，提炼成更为抽象的数据间的映射关系，并由Haskell编译器根据数据映射关系自动规划变量的读写时机，以正确实现算法的功能。这样做的一个明显的好处，就是Haskell程序员不必花费大量精力去规划变量的存取时机，而可以专注于算法本身的数据映射的正确性上。我们知道，程序设计中的错误，有很大一部分就来源于错误的变量存取时机。而由Haskell编译器自动规划的变量存取，总可以保证其正确性。所以，只要Haskell程序所设计的算法间的数据映射关系正确，则编译出的目标代码就可以得到正确的结果。这大大降低了程序出错的概率，使得代码更加可读也更易维护。《Real World Haskell》的作者曾在该书前言中说到：
#+BEGIN_QUOTE
Even with years of experience, we remain astonished and pleased by how often our Haskell programs simply work on the first try, once we fix those compilation errors.

我们经常发现，在修复所有的编译错误后Haskell程序第一次运行便可正确工作。对此，即使有多年经验的我们仍然会感到惊讶与欣喜。
#+END_QUOTE
对于这一点，仅有一点Haskell编程经历的我深表赞同。

*** 用公式编程

接下来，通过一个实际的算法例子来体会没有变量的Haskell的解题思路。

回到“交换两个变量中的数据”的问题。由于Haskell中没有变量，所以也无需去交换两个变量的数据。那么，在其它语言中需要交换两个变量的算法，在Haskell中应该如何实现呢？比如，冒泡排序就是一个典型的需要交换两变量数据的算法。为了简化讨论，我们在这里只考虑冒泡排序中的冒泡问题，即给定一个序列，如何将该序列的最大元素移动到序列首。并且，由于Haskell中最方便的数据结构是单向链表，在此，我们约定序列是保存在单向链表中。

在有变量的程序语言中，这一问题可以通过一个循环解决。通过循环，从链表首节点遍历到链表的尾节点之前的节点，当当前节点的数据大于下一个节点的数据时，交换这两个节点的数据[fn:exchange_node]。这样，遍历结束后，最大数据将保存在链表尾节点中。最后，再交换链表首尾节点的数据即可。该算法及单向链表节点的一个最简C++实现如下例所示。

#+INCLUDE: "../src/examples/bubble.cpp" src c++ :lines "6-23"

循环总是需要有一个循环变量，在循环过程中其数据不断更新。但是由于Haskell没有变量，所以也没有循环语句。要使用Haskell解决冒泡问题，我们必须忘记变量、忘记循环，从程序语言诞生之前的人类智慧中寻找思路。

这一智慧就是数学。

具体来说，用数学解决冒泡问题，我们需要构造出一个函数，函数的输入是某种形式的序列，输出也是同种形式的序列，并且满足输出序列是输出序列的重排列以及输出序列的首元素是序列中的最大元素。由于问题中并没有约束序列的长度（即列表的元素数），所以构造出的函数（或者函数集）必须能处理任意长度的序列。

对于这种针对任意数目的函数构造或证明，数学上有一个强有力的工具，即数学归纳法。假设针对长度为 $n-1$ 的序列，我们已经构造出满足条件的函数 $Bub^{n-1}$ ，那么，如果可以利用 $Bub^{n-1}$ 构造出针对长度为 $n$ 的序列的函数 $Bub^n$ ，并且针对元素为1的序列已经找到一个种子函数 $Bub^1$ ，则根据数学归纳法，我们便可以为任意长度的序列构造冒泡函数，从而解决冒泡问题。

种子函数 $Bub^1$ 很容易找到。对于长度为1的序列，其本身已经满足首元素最大，所以函数无需对序列做任何操作，只需要返回该序列即可，既 $Bub^1(L)=L$ 。

问题的关键在于找到从 $Bub^{n-1}$ 构造 $Bub^n$ 的方法。这也不是什么难事。任意长度为 $n$ 的序列 $L$ ，当 $n>0$ 时，总可以分解成首元素 $e$ 和将 $e$ 从 $L$ 中移除后的剩余序列 $L_r$ , $L_r$ 长度为 $n-1$ ，所以可以通过 $Bub^{n-1}$ 得到冒泡后的序列 $L'=Bub^{n-1}(L_r)$ 。同样， $L'$ 也可以分解成其首元素 $e'$ 和剩余序列 $L'_r$ 。此时， $L$ 已经经过两重分解，得到两个元素 $e$ 、 $e'$ 和一个剩余序列 $L'_r$ ，并且对于任意 $L'_r$ 中的元素 $e_r$，都满足 $e'>e_r$ 。那么，当 $e'>e$ 时， $e'$ 就是序列 $L$ 中最大的元素，否则 $e$ 就是最大元素，只需选择其中较大者做为函数返回序列的首元素，再与较小者和剩余序列 $L'_r$ 组成完整序列即可。

将以上讨论中所用到的几种对序列的操作，以函数的形式标记如下：
  * $Head(L)$ 返回序列的首元素。
  * $Tail(L)$ 返回序列将首元素移除后的剩余序列。
  * $Cons(e, L)$ 构造一个新序列 $L'$ ， $L'$ 满足 $Head(L')=e$ 及 $Tail(L')=L$ 。
对于单向链表来说，以上几种函数的操作都很容易实现。

那么，冒泡函数 $Bub^n$ 可以写成如下形式。
\begin{equation}
\begin{array}{rcl}
Bub^1(L) & = & L \\
Bub^n(L) & = &
\left\{ 
\begin{array}{ll}
Cons(e, Cons(e', L')) & \textrm{if $e>e'$} \\
Cons(e', Cons(e, L')) & \textrm{otherwise}
\end{array}
\right. \\
& \textrm{Where} & 
\begin{array}{rcl}
e & = & Head(L) \\
L_r & = & Tail(L) \\
e' & = & Head(L_r) \\
L' & = & Tail(L_r)
\end{array}
\end{array}
\end{equation}


在这一点上，变量之于程序语言，相当于离合器之于汽车。同样，驾驶手动档汽车的驾驶员，除了要规划路径，观察路面情况外，还要分出一部分精力注意发动机转速并及时换档。

[fn:exchange_node] 当数据尺寸较大，使得交换两数据的运行开销较大时，更经济的方法是交换两节点在链表中的位置。在此，为使讨论简单，只考虑交换两数据的情况。
